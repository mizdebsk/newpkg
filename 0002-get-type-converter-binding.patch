From 04db80a7bc5d783404caae072dc9708f59aaf0cf Mon Sep 17 00:00:00 2001
From: Stanislav Ochotnicky <sochotnicky@redhat.com>
Date: Thu, 7 Oct 2010 14:41:14 +0200
Subject: [PATCH 2/3] get type converter binding

---
 src/com/google/inject/Injector.java                |   10 ++++
 src/com/google/inject/internal/Errors.java         |   19 ++++---
 .../google/inject/internal/InheritingState.java    |   15 +++---
 src/com/google/inject/internal/InjectorImpl.java   |   31 ++++++++---
 .../inject/internal/InternalInjectorCreator.java   |    4 ++
 .../inject/internal/MatcherAndConverter.java       |   56 --------------------
 src/com/google/inject/internal/State.java          |   15 +++---
 .../internal/TypeConverterBindingProcessor.java    |    6 +-
 .../inject/spi/ConvertedConstantBinding.java       |    7 ++-
 .../google/inject/spi/TypeConverterBinding.java    |    7 ++-
 test/com/google/inject/TypeConversionTest.java     |   10 ++++
 11 files changed, 87 insertions(+), 93 deletions(-)
 delete mode 100644 src/com/google/inject/internal/MatcherAndConverter.java

diff --git a/src/com/google/inject/Injector.java b/src/com/google/inject/Injector.java
index 64b584e..eff67ad 100644
--- a/src/com/google/inject/Injector.java
+++ b/src/com/google/inject/Injector.java
@@ -20,6 +20,8 @@ import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
 
+import com.google.inject.spi.TypeConverterBinding;
+
 /**
  * Builds the graphs of objects that make up your application. The injector tracks the dependencies
  * for each type and uses bindings to inject them. This is the core of Guice, although you rarely
@@ -247,4 +249,12 @@ public interface Injector {
    * @since 3.0
    */
   Map<Class<? extends Annotation>, Scope> getScopeBindings();
+
+  /**
+   * Returns a list containing all type converter bindings in the injector. The returned list
+   * is immutable.
+   *
+   * <p>This method is part of the Guice SPI and is intended for use by tools and extensions.
+   */
+  List<TypeConverterBinding> getTypeConverterBindings();
 }
diff --git a/src/com/google/inject/internal/Errors.java b/src/com/google/inject/internal/Errors.java
index 84fd96e..5baaa27 100644
--- a/src/com/google/inject/internal/Errors.java
+++ b/src/com/google/inject/internal/Errors.java
@@ -33,6 +33,7 @@ import com.google.inject.spi.Dependency;
 import com.google.inject.spi.InjectionListener;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.Message;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.io.PrintWriter;
 import java.io.Serializable;
@@ -51,7 +52,7 @@ import java.util.List;
 
 /**
  * A collection of error messages. If this type is passed as a method parameter, the method is
- * considered to have executed succesfully only if new errors were not added to this collection.
+ * considered to have executed successfully only if new errors were not added to this collection.
  *
  * <p>Errors can be chained to provide additional context. To add context, call {@link #withSource}
  * to create a new Errors instance that contains additional context. All messages added to the
@@ -135,30 +136,30 @@ public final class Errors implements Serializable {
   }
 
   public Errors converterReturnedNull(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding) {
     return addMessage("Received null converting '%s' (bound at %s) to %s%n"
         + " using %s.",
-        stringValue, convert(source), type, matchingConverter);
+        stringValue, convert(source), type, typeConverterBinding);
   }
 
   public Errors conversionTypeError(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter matchingConverter, Object converted) {
+      TypeConverterBinding typeConverterBinding, Object converted) {
     return addMessage("Type mismatch converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Converter returned %s.",
-        stringValue, convert(source), type, matchingConverter, converted);
+        stringValue, convert(source), type, typeConverterBinding, converted);
   }
 
   public Errors conversionError(String stringValue, Object source,
-      TypeLiteral<?> type, MatcherAndConverter matchingConverter, RuntimeException cause) {
+      TypeLiteral<?> type, TypeConverterBinding typeConverterBinding, RuntimeException cause) {
     return errorInUserCode(cause, "Error converting '%s' (bound at %s) to %s%n"
         + " using %s.%n"
         + " Reason: %s",
-        stringValue, convert(source), type, matchingConverter, cause);
+        stringValue, convert(source), type, typeConverterBinding, cause);
   }
 
   public Errors ambiguousTypeConversion(String stringValue, Object source, TypeLiteral<?> type,
-      MatcherAndConverter a, MatcherAndConverter b) {
+      TypeConverterBinding a, TypeConverterBinding b) {
     return addMessage("Multiple converters can convert '%s' (bound at %s) to %s:%n"
         + " %s and%n"
         + " %s.%n"
@@ -604,7 +605,7 @@ public final class Errors implements Serializable {
     }
 
     boolean appliesTo(Object o) {
-      return type.isAssignableFrom(o.getClass());
+      return o != null && type.isAssignableFrom(o.getClass());
     }
 
     String convert(Object o) {
diff --git a/src/com/google/inject/internal/InheritingState.java b/src/com/google/inject/internal/InheritingState.java
index 4050b1e..288d875 100644
--- a/src/com/google/inject/internal/InheritingState.java
+++ b/src/com/google/inject/internal/InheritingState.java
@@ -24,6 +24,7 @@ import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.Lists;
 import com.google.inject.internal.util.Maps;
 import static com.google.inject.internal.util.Preconditions.checkNotNull;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.spi.TypeListenerBinding;
 import java.lang.annotation.Annotation;
 import java.util.ArrayList;
@@ -43,7 +44,7 @@ final class InheritingState implements State {
   private final Map<Key<?>, Binding<?>> explicitBindings
       = Collections.unmodifiableMap(explicitBindingsMutable);
   private final Map<Class<? extends Annotation>, Scope> scopes = Maps.newHashMap();
-  private final List<MatcherAndConverter> converters = Lists.newArrayList();
+  private final List<TypeConverterBinding> converters = Lists.newArrayList();
   /*if[AOP]*/
   private final List<MethodAspect> methodAspects = Lists.newArrayList();
   /*end[AOP]*/
@@ -83,19 +84,19 @@ final class InheritingState implements State {
     scopes.put(annotationType, scope);
   }
 
-  public Iterable<MatcherAndConverter> getConvertersThisLevel() {
+  public List<TypeConverterBinding> getConvertersThisLevel() {
     return converters;
   }
 
-  public void addConverter(MatcherAndConverter matcherAndConverter) {
-    converters.add(matcherAndConverter);
+  public void addConverter(TypeConverterBinding typeConverterBinding) {
+    converters.add(typeConverterBinding);
   }
 
-  public MatcherAndConverter getConverter(
+  public TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source) {
-    MatcherAndConverter matchingConverter = null;
+    TypeConverterBinding matchingConverter = null;
     for (State s = this; s != State.NONE; s = s.parent()) {
-      for (MatcherAndConverter converter : s.getConvertersThisLevel()) {
+      for (TypeConverterBinding converter : s.getConvertersThisLevel()) {
         if (converter.getTypeMatcher().matches(type)) {
           if (matchingConverter != null) {
             errors.ambiguousTypeConversion(stringValue, source, type, matchingConverter, converter);
diff --git a/src/com/google/inject/internal/InjectorImpl.java b/src/com/google/inject/internal/InjectorImpl.java
index ab8e281..73ad4d3 100644
--- a/src/com/google/inject/internal/InjectorImpl.java
+++ b/src/com/google/inject/internal/InjectorImpl.java
@@ -45,6 +45,7 @@ import com.google.inject.spi.Dependency;
 import com.google.inject.spi.HasDependencies;
 import com.google.inject.spi.InjectionPoint;
 import com.google.inject.spi.ProviderBinding;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.util.Providers;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.GenericArrayType;
@@ -376,9 +377,9 @@ final class InjectorImpl implements Injector, Lookups {
 
     // Find a matching type converter.
     TypeLiteral<T> type = key.getTypeLiteral();
-    MatcherAndConverter matchingConverter = state.getConverter(stringValue, type, errors, source);
+    TypeConverterBinding typeConverterBinding = state.getConverter(stringValue, type, errors, source);
 
-    if (matchingConverter == null) {
+    if (typeConverterBinding == null) {
       // No converter can handle the given type.
       return null;
     }
@@ -386,23 +387,24 @@ final class InjectorImpl implements Injector, Lookups {
     // Try to convert the string. A failed conversion results in an error.
     try {
       @SuppressWarnings("unchecked") // This cast is safe because we double check below.
-      T converted = (T) matchingConverter.getTypeConverter().convert(stringValue, type);
+      T converted = (T) typeConverterBinding.getTypeConverter().convert(stringValue, type);
 
       if (converted == null) {
-        throw errors.converterReturnedNull(stringValue, source, type, matchingConverter)
+        throw errors.converterReturnedNull(stringValue, source, type, typeConverterBinding)
             .toException();
       }
 
       if (!type.getRawType().isInstance(converted)) {
-        throw errors.conversionTypeError(stringValue, source, type, matchingConverter, converted)
+        throw errors.conversionTypeError(stringValue, source, type, typeConverterBinding, converted)
             .toException();
       }
 
-      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding);
+      return new ConvertedConstantBindingImpl<T>(this, key, converted, stringBinding,
+          typeConverterBinding);
     } catch (ErrorsException e) {
       throw e;
     } catch (RuntimeException e) {
-      throw errors.conversionError(stringValue, source, type, matchingConverter, e)
+      throw errors.conversionError(stringValue, source, type, typeConverterBinding, e)
           .toException();
     }
   }
@@ -412,14 +414,17 @@ final class InjectorImpl implements Injector, Lookups {
     final T value;
     final Provider<T> provider;
     final Binding<String> originalBinding;
+    final TypeConverterBinding typeConverterBinding;
 
     ConvertedConstantBindingImpl(
-        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding) {
+        InjectorImpl injector, Key<T> key, T value, Binding<String> originalBinding,
+        TypeConverterBinding typeConverterBinding) {
       super(injector, key, originalBinding.getSource(),
           new ConstantFactory<T>(Initializables.of(value)), Scoping.UNSCOPED);
       this.value = value;
       provider = Providers.of(value);
       this.originalBinding = originalBinding;
+      this.typeConverterBinding = typeConverterBinding;
     }
 
     @Override public Provider<T> getProvider() {
@@ -434,6 +439,10 @@ final class InjectorImpl implements Injector, Lookups {
       return value;
     }
 
+    public TypeConverterBinding getTypeConverterBinding() {
+      return typeConverterBinding;
+    }
+
     public Key<String> getSourceKey() {
       return originalBinding.getKey();
     }
@@ -828,7 +837,11 @@ final class InjectorImpl implements Injector, Lookups {
   }
 
   public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
-    return state.getScopes();
+    return Collections.unmodifiableMap(state.getScopes());
+  }
+
+  public List<TypeConverterBinding> getTypeConverterBindings() {
+    return Collections.unmodifiableList(state.getConvertersThisLevel());
   }
 
   private static class BindingsMultimap {
diff --git a/src/com/google/inject/internal/InternalInjectorCreator.java b/src/com/google/inject/internal/InternalInjectorCreator.java
index 44f0065..5c6d9e0 100644
--- a/src/com/google/inject/internal/InternalInjectorCreator.java
+++ b/src/com/google/inject/internal/InternalInjectorCreator.java
@@ -25,6 +25,7 @@ import com.google.inject.Provider;
 import com.google.inject.Scope;
 import com.google.inject.Stage;
 import com.google.inject.TypeLiteral;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.internal.util.ImmutableSet;
 import com.google.inject.internal.util.Iterables;
 import com.google.inject.internal.util.Stopwatch;
@@ -287,6 +288,9 @@ public final class InternalInjectorCreator {
     public Map<Class<? extends Annotation>, Scope> getScopeBindings() {
       return delegateInjector.getScopeBindings();
     }
+    public List<TypeConverterBinding> getTypeConverterBindings() {
+      return delegateInjector.getTypeConverterBindings();
+    }
     public <T> Provider<T> getProvider(Key<T> key) {
       throw new UnsupportedOperationException(
         "Injector.getProvider(Key<T>) is not supported in Stage.TOOL");
diff --git a/src/com/google/inject/internal/MatcherAndConverter.java b/src/com/google/inject/internal/MatcherAndConverter.java
deleted file mode 100644
index b618b3f..0000000
--- a/src/com/google/inject/internal/MatcherAndConverter.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2007 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.inject.internal;
-
-import com.google.inject.TypeLiteral;
-import static com.google.inject.internal.util.Preconditions.checkNotNull;
-import com.google.inject.matcher.Matcher;
-import com.google.inject.spi.TypeConverter;
-
-/**
- * @author crazybob@google.com (Bob Lee)
- */
-final class MatcherAndConverter {
-
-  private final Matcher<? super TypeLiteral<?>> typeMatcher;
-  private final TypeConverter typeConverter;
-  private final Object source;
-
-  public MatcherAndConverter(Matcher<? super TypeLiteral<?>> typeMatcher,
-      TypeConverter typeConverter, Object source) {
-    this.typeMatcher = checkNotNull(typeMatcher, "type matcher");
-    this.typeConverter = checkNotNull(typeConverter, "converter");
-    this.source = source;
-  }
-
-  public TypeConverter getTypeConverter() {
-    return typeConverter;
-  }
-
-  public Matcher<? super TypeLiteral<?>> getTypeMatcher() {
-    return typeMatcher;
-  }
-
-  public Object getSource() {
-    return source;
-  }
-
-  @Override public String toString() {
-    return typeConverter + " which matches " + typeMatcher
-        + " (bound at " + source + ")";
-  }
-}
diff --git a/src/com/google/inject/internal/State.java b/src/com/google/inject/internal/State.java
index 4bf8025..743092b 100644
--- a/src/com/google/inject/internal/State.java
+++ b/src/com/google/inject/internal/State.java
@@ -20,6 +20,7 @@ import com.google.inject.Binding;
 import com.google.inject.Key;
 import com.google.inject.Scope;
 import com.google.inject.TypeLiteral;
+import com.google.inject.spi.TypeConverterBinding;
 import com.google.inject.internal.util.ImmutableList;
 import com.google.inject.internal.util.ImmutableMap;
 import com.google.inject.internal.util.ImmutableSet;
@@ -61,17 +62,17 @@ interface State {
       throw new UnsupportedOperationException();
     }
 
-    public void addConverter(MatcherAndConverter matcherAndConverter) {
+    public void addConverter(TypeConverterBinding typeConverterBinding) {
       throw new UnsupportedOperationException();
     }
 
-    public MatcherAndConverter getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
+    public TypeConverterBinding getConverter(String stringValue, TypeLiteral<?> type, Errors errors,
         Object source) {
       throw new UnsupportedOperationException();
     }
 
-    public Iterable<MatcherAndConverter> getConvertersThisLevel() {
-      return ImmutableSet.of();
+    public List<TypeConverterBinding> getConvertersThisLevel() {
+      return ImmutableList.of();
     }
 
     /*if[AOP]*/
@@ -123,14 +124,14 @@ interface State {
 
   void putAnnotation(Class<? extends Annotation> annotationType, Scope scope);
 
-  void addConverter(MatcherAndConverter matcherAndConverter);
+  void addConverter(TypeConverterBinding typeConverterBinding);
 
   /** Returns the matching converter for {@code type}, or null if none match. */
-  MatcherAndConverter getConverter(
+  TypeConverterBinding getConverter(
       String stringValue, TypeLiteral<?> type, Errors errors, Object source);
 
   /** Returns all converters at this level only. */
-  Iterable<MatcherAndConverter> getConvertersThisLevel();
+  List<TypeConverterBinding> getConvertersThisLevel();
 
   /*if[AOP]*/
   void addMethodAspect(MethodAspect methodAspect);
diff --git a/src/com/google/inject/internal/TypeConverterBindingProcessor.java b/src/com/google/inject/internal/TypeConverterBindingProcessor.java
index 1f10349..ceb0657 100644
--- a/src/com/google/inject/internal/TypeConverterBindingProcessor.java
+++ b/src/com/google/inject/internal/TypeConverterBindingProcessor.java
@@ -161,12 +161,12 @@ final class TypeConverterBindingProcessor extends AbstractProcessor {
   private void internalConvertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter converter) {
     injector.state.addConverter(
-        new MatcherAndConverter(typeMatcher, converter, SourceProvider.UNKNOWN_SOURCE));
+        new TypeConverterBinding(SourceProvider.UNKNOWN_SOURCE, typeMatcher, converter));
   }
 
   @Override public Boolean visit(TypeConverterBinding command) {
-    injector.state.addConverter(new MatcherAndConverter(
-        command.getTypeMatcher(), command.getTypeConverter(), command.getSource()));
+    injector.state.addConverter(new TypeConverterBinding(
+        command.getSource(), command.getTypeMatcher(), command.getTypeConverter()));
     return true;
   }
 }
diff --git a/src/com/google/inject/spi/ConvertedConstantBinding.java b/src/com/google/inject/spi/ConvertedConstantBinding.java
index 6c78acb..285ca30 100644
--- a/src/com/google/inject/spi/ConvertedConstantBinding.java
+++ b/src/com/google/inject/spi/ConvertedConstantBinding.java
@@ -35,6 +35,11 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
   T getValue();
 
   /**
+   * Returns the type converter binding used to convert the constant.
+   */
+  TypeConverterBinding getTypeConverterBinding();
+
+  /**
    * Returns the key for the source binding. That binding can e retrieved from an injector using
    * {@link com.google.inject.Injector#getBinding(Key) Injector.getBinding(key)}.
    */
@@ -44,4 +49,4 @@ public interface ConvertedConstantBinding<T> extends Binding<T>, HasDependencies
    * Returns a singleton set containing only the converted key.
    */
   Set<Dependency<?>> getDependencies();
-}
\ No newline at end of file
+}
diff --git a/src/com/google/inject/spi/TypeConverterBinding.java b/src/com/google/inject/spi/TypeConverterBinding.java
index 74f7c73..9564715 100644
--- a/src/com/google/inject/spi/TypeConverterBinding.java
+++ b/src/com/google/inject/spi/TypeConverterBinding.java
@@ -36,7 +36,7 @@ public final class TypeConverterBinding implements Element {
   private final Matcher<? super TypeLiteral<?>> typeMatcher;
   private final TypeConverter typeConverter;
 
-  TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
+  public TypeConverterBinding(Object source, Matcher<? super TypeLiteral<?>> typeMatcher,
       TypeConverter typeConverter) {
     this.source = checkNotNull(source, "source");
     this.typeMatcher = checkNotNull(typeMatcher, "typeMatcher");
@@ -62,4 +62,9 @@ public final class TypeConverterBinding implements Element {
   public void applyTo(Binder binder) {
     binder.withSource(getSource()).convertToTypes(typeMatcher, typeConverter);
   }
+
+  @Override public String toString() {
+    return typeConverter + " which matches " + typeMatcher
+        + " (bound at " + source + ")";
+  }
 }
diff --git a/test/com/google/inject/TypeConversionTest.java b/test/com/google/inject/TypeConversionTest.java
index ead3c99..3d57d31 100644
--- a/test/com/google/inject/TypeConversionTest.java
+++ b/test/com/google/inject/TypeConversionTest.java
@@ -19,7 +19,9 @@ package com.google.inject;
 import static com.google.inject.Asserts.assertContains;
 import com.google.inject.internal.util.Iterables;
 import com.google.inject.matcher.Matchers;
+import com.google.inject.spi.ConvertedConstantBinding;
 import com.google.inject.spi.TypeConverter;
+import com.google.inject.spi.TypeConverterBinding;
 import java.lang.annotation.Retention;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.util.Date;
@@ -209,6 +211,14 @@ public class TypeConversionTest extends TestCase {
     });
 
     assertSame(result, injector.getInstance(DateHolder.class).date);
+
+    Binding<Date> binding = injector.getBinding(Key.get(Date.class, NumericValue.class));
+    assertTrue(binding instanceof ConvertedConstantBinding<?>);
+
+    TypeConverterBinding converterBinding = ((ConvertedConstantBinding<?>)binding).getTypeConverterBinding();
+    assertEquals("CustomConverter", converterBinding.getTypeConverter().toString());
+
+    assertTrue(injector.getTypeConverterBindings().contains(converterBinding));
   }
 
   public void testInvalidCustomValue() throws CreationException {
-- 
1.7.2.3

